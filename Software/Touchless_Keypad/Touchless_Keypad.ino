

/*
  author: Gritti Francesco

  date: 08/28/2020

  target device: Arduino MKR WiFi 1010

  description: this is the main program of the Touchless keypad Adaptor Project. It functions are:
   - handles Bluetooth connections;
   - reads the touch-less infarred matrix;
   - communicates with the axes controller board;
   - store the keypad layout configuration into the external EEPROM and reads it at startup;

  The bluetooth connection is acomplished as following: the BLE module mounted on the Arduino MKR 1010 advertises the
  other devices sending his manufacturer data. The manufacturer data is a 8 Byte unique ID. the same ID must be generated
  by the QR Code associated with the touch-less keypad adaptor. When the user wants to connect with a touch-less keypad, he has
  to scan the QR code associated with it from the applications. Then the applications scans all the bluetooth devices looking
  for one width the same manufacturer data as the data read form the QR code. If it finds the device, than the apllications connects with it.

*/


#include <ArduinoBLE.h>
#include <Servo.h>
#include <Wire.h>

#include "EEPROM_Handler.h";
#include "IR_Matrix_Handler.h"


/* I2C peripheral defines */
#define SET_TARGET_POSITION_COMMAND   0x01    // command to communicate to the I2C motor controller that we want to set a new target position
#define I2C_ADDRESS                   0x30    // motor controller I2C address

#define INTERRUPT_PIN 5                       // interrupt pin: when HIGH the motor controller has reached the target position, when LOW it is moving


/* GPIO's used to read the infrared sensors matrix */
#define IR_Emitter_Matrix_b0  A1
#define IR_Emitter_Matrix_b1  A2
#define IR_Emitter_Matrix_b2  A3
#define IR_Emitter_Matrix_b3  A4

#define IR_Emitter_Matrix_Input A0

#define BUZZER_PIN  4   // pin connected to the buzzer

/* servo defines */
#define SERVO_PIN   2   // pin connected to the servo

#define IDLE_ANGLE  120     // rest angle of the servo
#define PRESSED_ANGLE 60    // angle of the servo at which it presse a button of the phisical keyboard




// offset in mm from the center of the tag
int16_t offsetX = 56;
int16_t offsetY = 55;

// ratio encoder_step / mm
double resolutionY = 0.469135802;
double resolutionX = 0.709677419;



/* Manufacturer data contains the univoque ID of this keypad adaptor.
   This code is used by the application to automaticly connect to bluetooth.
   It must be the same as the ID generated by the associated QR code.
*/
byte manufacturerData[8] = {0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x7a, 0x8b};


const char * touchlessKeypadServideUUID = "19B10000-E8F2-537E-4F6C-D104768A1214";
const char * keyPressedCharacteristicUUID = "19B10001-E8F2-537E-4F6C-D104768A1214";

const char * touchlessKeypadConfigurationServideUUID = "19B10000-E8F2-537E-4F6C-D104768A9183";
const char * touchlessKeypadConfigurationCharacteristicUUID = "19B10001-E8F2-537E-4F6C-D104768A9183";


/* objects declaration */

Servo servo;    // servomotor used to press a button of the phisical keypad

BLEService touchlessKeypadService(touchlessKeypadServideUUID);
BLEByteCharacteristic keyPressedCharacteristic(keyPressedCharacteristicUUID, BLERead | BLEWrite);

BLEService touchlessKeypadConfigurationService(touchlessKeypadConfigurationServideUUID);
BLECharacteristic keypadConfigurationCharacteristic(touchlessKeypadConfigurationCharacteristicUUID, BLERead | BLEWrite | BLENotify, 275, false);

IREmitterMatrix_Handler matrixHandler (IR_Emitter_Matrix_b0, IR_Emitter_Matrix_b1, IR_Emitter_Matrix_b2, IR_Emitter_Matrix_b3, IR_Emitter_Matrix_Input);


/* when set to true meandÃ¬s that when the axes controller board reaches the target position, the servo has to move down
   to press a button on the phisical keypad */
bool needToPress = false;



#pragma pack(1)


class Button {
  public:
    char value[6];
    int16_t xPos;
    int16_t yPos;

    uint8_t tag;
};

Button buttons[25] {};
uint8_t numberOfButtons = 0;

bool saveKeypadLayout = false;

const int ledPin = LED_BUILTIN; // pin connected to the onboard LED

uint8_t * rowOrderedButtonTag;
uint8_t * columnOrderedButtonTag;


uint8_t buttonGrid[5][5] {};

uint8_t gridColumns, gridRows;

bool IR_MatrixIdleState = true;



/* Function prototypes */


/* checks if the IR matrix detected something. If so, read the grid position (row and column of the object), get the
   corresponding button positions and call "pressButton" for that button*/
void matrixCheckRoutine();

/* if the user pressed a button on the application or through the touch-less IR matrix, the system has to press the 
   phisical button. This function gets the button position from it's index in the buttons array and than tells the
   axes controller to go to that position*/
void pressButton(uint8_t buttonIndex);

/* this function does two things: first checks if the motor controller board reached the target position,
    if so than press the button by moving down and up the servomotor */
void checkMotorControllerStatus();

/* this function issues a "set target position command" through the I2C bus to the axes controller board */
void setTargetPositions(int xPos, int yPos);

/* given the button tag, this function returnes the index position inside of the buttons array */
int8_t buttonIndexForTag(uint8_t _tag);

/* This function reads the keypad configuration from the external EEPROM*/
void readKeypadLayout ();


/* since the buttons positions are saved as they are in the reality but the IR matrix is layout as a grid, with rows and columns,
   the real buttons positions must be arranged in a grid, assigning each of them to a cell. this functions searches which buttons
   are on the same column and which are on the same row and it then compiles the matrix "buttonGrid" */
void compileButtonGrid();


void setup() {

  Serial.begin(115200);
  Wire.begin();

  while (!Serial);

  // GPIO setup
  pinMode(ledPin, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(INTERRUPT_PIN, INPUT);

  servo.attach(SERVO_PIN);

  // Infrared matrix init
  matrixHandler.init();
  matrixHandler.setValue(0);


  // BLE initialization
  if (!BLE.begin()) {
    Serial.println("starting BLE failed!");
    while (1);
  }


  // set local name, device name and advertise service UUID:
  BLE.setLocalName("Touchless Keypad");
  BLE.setDeviceName("Touchless Keypad");

  BLE.setAdvertisedServiceUuid(touchlessKeypadServideUUID);
  BLE.setManufacturerData(manufacturerData, 8);

  // add characteristich and services
  touchlessKeypadService.addCharacteristic(keyPressedCharacteristic);
  BLE.addService(touchlessKeypadService);

  touchlessKeypadConfigurationService.addCharacteristic(keypadConfigurationCharacteristic);
  BLE.addService(touchlessKeypadConfigurationService);

  // set BLE events handler
  keypadConfigurationCharacteristic.setEventHandler(BLEWritten, newConfigurationWrittenHandler);
  keyPressedCharacteristic.setEventHandler(BLEWritten, buttonPressedHandler);

  // set the initial value for the characeristic:
  keyPressedCharacteristic.writeValue(0);

  Serial.println("BLE Touchless Keypad");


  // read the keypad layout from the external EEPROM memory
  Serial.println("Read layout from EEPROM ...");
  readKeypadLayout();

  // write the loaded keypad configuration to the configuration characteristic
  keypadConfigurationCharacteristic.writeValue((void*)buttons, sizeof(Button)*numberOfButtons);

  // start advertising
  BLE.advertise();


  compileButtonGrid();
}




void loop() {

  // check if the matrix has detected something
  matrixCheckRoutine();
  checkMotorControllerStatus();

  // listen for BLE peripherals to connect:
  BLEDevice central = BLE.central();

  // if a central is connected to peripheral:
  if (central) {

    Serial.print("Connected to central: ");
    // print the central's MAC address:
    Serial.println(central.address());

    BLE.stopAdvertise();

    // while the central is still connected to peripheral:
    while (central.connected()) {

      // check if the matrix has detected something
      matrixCheckRoutine();
      checkMotorControllerStatus();

      // if the keypad layout configuration was change, save the new one into the external EEPROM
      if (saveKeypadLayout) {
        saveKeypadLayout = false;

        Serial.print("Write new configuration...");
        EEPROM_writeBuffer(1, (uint8_t*)buttons, 255);
        EEPROM_writeBuffer(256, (uint8_t*)(buttons + 255), 256);
        EEPROM_writeBuffer(0, &numberOfButtons, 1);
        Serial.println("DONE");
      }
    }

    // when the central disconnects, print it out:
    Serial.print(F("Disconnected from central: "));
    Serial.println(central.address());
  }
  BLE.advertise();
}


void matrixCheckRoutine () {
  uint8_t selectedRow, selectedColumn;

  int8_t pressed = matrixHandler.scan(&selectedRow, &selectedColumn);

  if (pressed && IR_MatrixIdleState) {

    IR_MatrixIdleState = false;
    uint8_t correspondingButtonTag = buttonGrid[selectedRow][selectedColumn];
    int8_t buttonIndex = buttonIndexForTag(correspondingButtonTag);

    if (buttonIndex != -1) {

      pressButton(buttonIndex);
      Serial.println(buttons[buttonIndex].value);
    }
    tone(BUZZER_PIN, 1200, 100);
  }
  else if (!pressed) {

    IR_MatrixIdleState = true;
  }
}

void pressButton(uint8_t buttonIndex) {

  int x_coordinate = buttons[buttonIndex].xPos;
  int y_coordinate = buttons[buttonIndex].yPos;
  Serial.print("desired pos: ("); Serial.print(x_coordinate); Serial.print(", "); Serial.print(y_coordinate); Serial.println(")");

  int targetX = int( double(offsetX - x_coordinate) * resolutionX);
  int targetY = int( double(y_coordinate - offsetY) * resolutionY);

  Serial.print("Target: ("); Serial.print(targetX); Serial.print(", "); Serial.print(targetY); Serial.println(")");
  setTargetPositions(targetX, targetY);

  needToPress = true;
}


void checkMotorControllerStatus() {

  if (digitalRead(INTERRUPT_PIN) == HIGH && needToPress) {
    Serial.println("PRESS");
    needToPress = false;

    delay(200);
    servo.write(PRESSED_ANGLE);
    delay(500);
    servo.write(IDLE_ANGLE);
  }
}


void setTargetPositions(int xPos, int yPos) {

  if (digitalRead(INTERRUPT_PIN) == LOW)return;

  Wire.beginTransmission(I2C_ADDRESS);

  Wire.write(SET_TARGET_POSITION_COMMAND);
  Wire.write(xPos >> 8);
  Wire.write(xPos);
  Wire.write(yPos >> 8);
  Wire.write(yPos);

  Wire.endTransmission();
}


int8_t buttonIndexForTag(uint8_t _tag) {

  for (uint8_t i = 0; i < numberOfButtons; i += 1) {
    if (buttons[i].tag == _tag) {
      return i;
    }
  }
  return -1;
}


void readKeypadLayout () {
  EEPROM_readBuffer(1, (uint8_t*)buttons, 255);
  EEPROM_readBuffer(256, (uint8_t*)(buttons + 255), 20);

  EEPROM_readBuffer(0, &numberOfButtons, 1);
  Serial.println(numberOfButtons);

  for (uint8_t i = 0;  i < numberOfButtons; i ++) {
    Serial.println();
    Serial.println(buttons[i].value);
    Serial.print(buttons[i].xPos); Serial.print(" . "); Serial.println(buttons[i].yPos);
    Serial.println(buttons[i].tag);
  }
}
